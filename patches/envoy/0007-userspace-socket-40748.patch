From 430653c77b3b98f48a3f6ab235e41bdf9cc8eb99 Mon Sep 17 00:00:00 2001
From: Joe Kralicky <joekralicky@gmail.com>
Date: Fri, 15 Aug 2025 22:53:42 +0000
Subject: [PATCH] userspace socket: allow providing an existing
 PassthroughState when creating IoHandle pair

Signed-off-by: Joe Kralicky <joekralicky@gmail.com>
---
 .../io_socket/user_space/io_handle.h          |  1 +
 .../io_socket/user_space/io_handle_impl.cc    | 35 ++++++++++++++++++
 .../io_socket/user_space/io_handle_impl.h     | 37 ++++++++-----------
 .../user_space/io_handle_impl_test.cc         | 22 +++++++++++
 4 files changed, 74 insertions(+), 21 deletions(-)

diff --git a/source/extensions/io_socket/user_space/io_handle.h b/source/extensions/io_socket/user_space/io_handle.h
index 8266c9e0b4..20c9e24f1e 100644
--- a/source/extensions/io_socket/user_space/io_handle.h
+++ b/source/extensions/io_socket/user_space/io_handle.h
@@ -32,6 +32,7 @@ public:
 };
 
 using PassthroughStateSharedPtr = std::shared_ptr<PassthroughState>;
+using PassthroughStatePtr = std::unique_ptr<PassthroughState>;
 
 /**
  * The interface for the peer as a writer and supplied read status query.
diff --git a/source/extensions/io_socket/user_space/io_handle_impl.cc b/source/extensions/io_socket/user_space/io_handle_impl.cc
index 8ca2088cb4..c08347967f 100644
--- a/source/extensions/io_socket/user_space/io_handle_impl.cc
+++ b/source/extensions/io_socket/user_space/io_handle_impl.cc
@@ -392,6 +392,41 @@ void PassthroughStateImpl::mergeInto(envoy::config::core::v3::Metadata& metadata
   filter_state_objects_.clear();
   state_ = State::Done;
 }
+
+std::pair<IoHandleImplPtr, IoHandleImplPtr>
+IoHandleFactory::createIoHandlePair(PassthroughStatePtr state) {
+  PassthroughStateSharedPtr shared_state;
+  if (state != nullptr) {
+    shared_state = std::move(state);
+  } else {
+    shared_state = std::make_shared<PassthroughStateImpl>();
+  }
+  auto p = std::pair<IoHandleImplPtr, IoHandleImplPtr>{new IoHandleImpl(shared_state),
+                                                       new IoHandleImpl(shared_state)};
+  p.first->setPeerHandle(p.second.get());
+  p.second->setPeerHandle(p.first.get());
+  return p;
+}
+
+std::pair<IoHandleImplPtr, IoHandleImplPtr>
+IoHandleFactory::createBufferLimitedIoHandlePair(uint32_t buffer_size, PassthroughStatePtr state) {
+  PassthroughStateSharedPtr shared_state;
+  if (state != nullptr) {
+    shared_state = std::move(state);
+  } else {
+    shared_state = std::make_shared<PassthroughStateImpl>();
+  }
+  auto p = std::pair<IoHandleImplPtr, IoHandleImplPtr>{new IoHandleImpl(shared_state),
+                                                       new IoHandleImpl(shared_state)};
+  // This buffer watermark setting emulates the OS socket buffer parameter
+  // `/proc/sys/net/ipv4/tcp_{r,w}mem`.
+  p.first->setWatermarks(buffer_size);
+  p.second->setWatermarks(buffer_size);
+  p.first->setPeerHandle(p.second.get());
+  p.second->setPeerHandle(p.first.get());
+  return p;
+}
+
 } // namespace UserSpace
 } // namespace IoSocket
 } // namespace Extensions
diff --git a/source/extensions/io_socket/user_space/io_handle_impl.h b/source/extensions/io_socket/user_space/io_handle_impl.h
index 0c75dfda4d..0b2e67553d 100644
--- a/source/extensions/io_socket/user_space/io_handle_impl.h
+++ b/source/extensions/io_socket/user_space/io_handle_impl.h
@@ -193,7 +193,7 @@ public:
   void mergeInto(envoy::config::core::v3::Metadata& metadata,
                  StreamInfo::FilterState& filter_state) override;
 
-private:
+protected:
   enum class State { Created, Initialized, Done };
   State state_{State::Created};
   std::unique_ptr<envoy::config::core::v3::Metadata> metadata_;
@@ -203,27 +203,22 @@ private:
 using IoHandleImplPtr = std::unique_ptr<IoHandleImpl>;
 class IoHandleFactory {
 public:
-  static std::pair<IoHandleImplPtr, IoHandleImplPtr> createIoHandlePair() {
-    auto state = std::make_shared<PassthroughStateImpl>();
-    auto p = std::pair<IoHandleImplPtr, IoHandleImplPtr>{new IoHandleImpl(state),
-                                                         new IoHandleImpl(state)};
-    p.first->setPeerHandle(p.second.get());
-    p.second->setPeerHandle(p.first.get());
-    return p;
-  }
+  /**
+   * @return a pair of connected IoHandleImpl instances.
+   * @param state optional existing value to use as the shared PassthroughState. If omitted, a
+   * newly constructed PassthroughStateImpl will be used.
+   */
   static std::pair<IoHandleImplPtr, IoHandleImplPtr>
-  createBufferLimitedIoHandlePair(uint32_t buffer_size) {
-    auto state = std::make_shared<PassthroughStateImpl>();
-    auto p = std::pair<IoHandleImplPtr, IoHandleImplPtr>{new IoHandleImpl(state),
-                                                         new IoHandleImpl(state)};
-    // This buffer watermark setting emulates the OS socket buffer parameter
-    // `/proc/sys/net/ipv4/tcp_{r,w}mem`.
-    p.first->setWatermarks(buffer_size);
-    p.second->setWatermarks(buffer_size);
-    p.first->setPeerHandle(p.second.get());
-    p.second->setPeerHandle(p.first.get());
-    return p;
-  }
+  createIoHandlePair(PassthroughStatePtr state = nullptr);
+
+  /**
+   * @return a pair of connected IoHandleImpl instances with pre-configured watermarks.
+   * @param buffer_size buffer watermark size in bytes
+   * @param state optional existing value to use as the shared PassthroughState. If omitted, a
+   * newly constructed PassthroughStateImpl will be used.
+   */
+  static std::pair<IoHandleImplPtr, IoHandleImplPtr>
+  createBufferLimitedIoHandlePair(uint32_t buffer_size, PassthroughStatePtr state = nullptr);
 };
 } // namespace UserSpace
 } // namespace IoSocket
diff --git a/test/extensions/io_socket/user_space/io_handle_impl_test.cc b/test/extensions/io_socket/user_space/io_handle_impl_test.cc
index bea47e6bdd..b05e365166 100644
--- a/test/extensions/io_socket/user_space/io_handle_impl_test.cc
+++ b/test/extensions/io_socket/user_space/io_handle_impl_test.cc
@@ -1293,6 +1293,28 @@ TEST_F(IoHandleImplNotImplementedTest, ErrorOnGetOption) {
 TEST_F(IoHandleImplNotImplementedTest, ErrorOnIoctl) {
   EXPECT_THAT(io_handle_->ioctl(0, nullptr, 0, nullptr, 0, nullptr), IsNotSupportedResult());
 }
+
+class TestPassthroughState : public PassthroughStateImpl {};
+
+TEST(IoHandleFactoryTest, UseExistingPassthroughState) {
+  {
+    auto [io_handle, io_handle_peer] =
+        IoHandleFactory::createIoHandlePair(std::make_unique<TestPassthroughState>());
+    EXPECT_NE(std::dynamic_pointer_cast<TestPassthroughState>(io_handle->passthroughState()),
+              nullptr);
+    EXPECT_NE(std::dynamic_pointer_cast<TestPassthroughState>(io_handle_peer->passthroughState()),
+              nullptr);
+  }
+  {
+    auto [io_handle, io_handle_peer] = IoHandleFactory::createBufferLimitedIoHandlePair(
+        1024, std::make_unique<TestPassthroughState>());
+    EXPECT_NE(std::dynamic_pointer_cast<TestPassthroughState>(io_handle->passthroughState()),
+              nullptr);
+    EXPECT_NE(std::dynamic_pointer_cast<TestPassthroughState>(io_handle_peer->passthroughState()),
+              nullptr);
+  }
+}
+
 } // namespace
 } // namespace UserSpace
 } // namespace IoSocket
-- 
2.43.0

