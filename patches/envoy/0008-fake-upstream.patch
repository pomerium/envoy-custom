diff --git a/test/integration/fake_upstream.cc b/test/integration/fake_upstream.cc
index 559484e147..fc2d34f653 100644
--- a/test/integration/fake_upstream.cc
+++ b/test/integration/fake_upstream.cc
@@ -681,7 +681,8 @@ FakeUpstream::FakeUpstream(Network::DownstreamTransportSocketFactoryPtr&& transp
       http3_options_(config.http3_options_), quic_options_(config.quic_options_),
       socket_(Network::SocketSharedPtr(listen_socket.release())),
       api_(Api::createApiForTest(stats_store_)), time_system_(config.time_system_),
-      dispatcher_(api_->allocateDispatcher("fake_upstream")),
+      dispatcher_(api_->allocateDispatcher(config.dispatcher_name_ != "" ? config.dispatcher_name_
+                                                                         : "fake_upstream")),
       handler_(new Server::ConnectionHandlerImpl(*dispatcher_, 0)), config_(config),
       read_disable_on_new_connection_(true), enable_half_close_(config.enable_half_close_),
       listener_(*this, http_type_ == Http::CodecType::HTTP3),
diff --git a/test/integration/fake_upstream.h b/test/integration/fake_upstream.h
index 42799230cc..382c147ffe 100644
--- a/test/integration/fake_upstream.h
+++ b/test/integration/fake_upstream.h
@@ -716,6 +716,7 @@ struct FakeUpstreamConfig {
   uint32_t max_request_headers_count_ = Http::DEFAULT_MAX_HEADERS_COUNT;
   envoy::config::core::v3::HttpProtocolOptions::HeadersWithUnderscoresAction
       headers_with_underscores_action_ = envoy::config::core::v3::HttpProtocolOptions::ALLOW;
+  std::string dispatcher_name_;
 };

 /**
@@ -765,6 +766,10 @@ public:
   ABSL_MUST_USE_RESULT
   testing::AssertionResult assertPendingConnectionsEmpty();

+  bool hasNewConnections() ABSL_EXCLUSIVE_LOCKS_REQUIRED(lock_) {
+    return !new_connections_.empty();
+  }
+
   ABSL_MUST_USE_RESULT
   testing::AssertionResult
   waitForRawConnection(FakeRawConnectionPtr& connection,
@@ -844,9 +849,13 @@ public:
   const envoy::config::core::v3::Http3ProtocolOptions& http3Options() { return http3_options_; }

   Event::DispatcherPtr& dispatcher() { return dispatcher_; }
-  absl::Mutex& lock() { return lock_; }
+  absl::Mutex& lock() ABSL_LOCK_RETURNED(lock_) { return lock_; }

   void runOnDispatcherThread(std::function<void()> cb);
+  AssertionResult
+  runOnDispatcherThreadAndWait(std::function<AssertionResult()> cb,
+                               std::chrono::milliseconds timeout = TestUtility::DefaultTimeout);
+  SharedConnectionWrapper& consumeConnection() ABSL_EXCLUSIVE_LOCKS_REQUIRED(lock_);

 protected:
   const FakeUpstreamConfig& config() const { return config_; }
@@ -993,11 +1002,7 @@ private:
   };

   void threadRoutine();
-  SharedConnectionWrapper& consumeConnection() ABSL_EXCLUSIVE_LOCKS_REQUIRED(lock_);
   Network::FilterStatus onRecvDatagram(Network::UdpRecvData& data);
-  AssertionResult
-  runOnDispatcherThreadAndWait(std::function<AssertionResult()> cb,
-                               std::chrono::milliseconds timeout = TestUtility::DefaultTimeout);

   const envoy::config::core::v3::Http2ProtocolOptions http2_options_;
   const envoy::config::core::v3::Http3ProtocolOptions http3_options_;
