#pragma once

#include "source/common/id_alloc.h"
#include "source/extensions/filters/network/ssh/common.h"
#include "source/extensions/filters/network/ssh/message_handler.h"
#include "source/extensions/filters/network/ssh/wire/messages.h"

namespace Envoy::Extensions::NetworkFilters::GenericProxy::Codec {

enum class Peer {
  Downstream = 1,
  Upstream = 2,
};

// Manages channel ID mappings.
// Channel IDs for proxied SSH connections are managed as follows:
//
// Both the downstream and upstream can open channels on the connection via ChannelOpenMsg. When
// doing so, whichever side opens the channel provides their own ID for that channel. Then, if the
// channel is opened successfully, the other side responds with *their* own channel ID for that
// channel. All channel messages after ChannelOpen, including the open response, have a field
// (in our messages, named 'recipient_channel') which contains the peer's channel ID for which the
// message applies. This ID is the one given by the peer itself.
//
// Thus, normally, any given channel can be identified by two separate IDs:
// 1. The ID provided by the downstream, which the upstream uses to send messages to the downstream
// 2. The ID provided by the upstream, which the downstream uses to send messages to the upstream
//
// In our case however, we maintain a third internal channel ID. Because we do not have control over
// the IDs generated by either party, forwarding channel IDs directly could lead to ID conflicts
// in some cases. For example, if we need to open a channel to the upstream ourselves, the
// downstream does not know this, and if it then tries to open another channel, it could generate
// the ID of a channel we have already created (the IDs are usually generated monotonically).
//
// To solve this, we do the following (note this is independent of which peer is the downstream or
// upstream, so we call them Alice and Bob):
// 1. A ChannelOpenMsg received from Alice has its 'sender_channel' field swapped with a
//    newly-generated internal channel ID before it is sent to Bob. The mapping between Alice's
//    sender_channel and ours is stored here, as the original sender_channel is the ID which must
//    be used when messages are ultimately sent back to Alice, regardless of source.
// 2. A ChannelOpenConfirmationMsg sent by Bob to Alice in response contains both sender_channel
//    and recipient_channel fields. The sender_channel here is Bob's new channel ID, and the
//    recipient_channel is *our* internal ID. Before forwarding this message to Alice, we will
//    make the following changes:
//    - The sender_channel (Bob's ID) is stored, and replaced with the recipient_channel (our ID).
//    - The recipient_channel is replaced with Alice's ID, obtained by lookup from our ID.
// 3. For any subsequent channel messages (see ChannelMsg), it can be assumed that the
//    recipient_channel refers to our own channel ID. If the message is to be sent to Bob, the
//    recipient_channel is replaced with Bob's ID, which was tracked in (2). If the message is to
//    be sent to Alice, the recipient_channel is replaced with Alice's ID, which was tracked in (1).
//
class ChannelIDManager : NonCopyable {
public:
  absl::StatusOr<uint32_t> newInternalChannel() {
    auto id = id_alloc_.alloc();
    if (!id.ok()) {
      return id.status();
    }
    internal_channels_[*id] = internalChannelInfo{
      // .opened_by = Source::Internal,
    };
    return *id;
  }

  absl::Status processIncomingChannelOpenMsg(wire::ChannelOpenMsg& msg, Peer source);

  absl::Status processIncomingChannelOpenConfirmationMsg(wire::ChannelOpenConfirmationMsg& msg, Peer source) {
    auto internalId = *msg.recipient_channel;
    auto it = internal_channels_.find(internalId);
    if (it == internal_channels_.end()) {
      return absl::InvalidArgumentError(fmt::format("received ChannelOpenConfirmationMsg for unknown channel {}", *msg.recipient_channel));
    }

    auto& info = it->second;
    switch (source) {
    case Peer::Downstream:
      // ChannelOpenConfirmation sent by the downstream in response to an open request
      info.downstream_id = msg.sender_channel;
      msg.sender_channel = internalId;
      break;
    case Peer::Upstream:
      // ChannelOpenConfirmation sent by the upstream in response to an open request
      info.upstream_id = msg.sender_channel;
      msg.sender_channel = internalId;
      break;
      // case Source::Internal:
      //   // ChannelOpenConfirmation sent by us; the IDs will already be correct, just keep track of
      //   // the recipient channel
      //   switch (source) {
      //   case Source::Downstream:
      //     info.downstream_id = msg.sender_channel;
      //     break;
      //   case Source::Upstream:
      //     info.upstream_id = msg.sender_channel;
      //     break;
      //   case Source::Internal:
      //     break;
      //   }
      //   break;
    }
    return absl::OkStatus();
  }

  template <wire::ChannelMsg M>
  absl::Status processOutgoingChannelMsg(M& msg, Peer dest) {
    auto internalId = *msg.recipient_channel;
    auto it = internal_channels_.find(internalId);
    if (it == internal_channels_.end()) {
      return absl::InvalidArgumentError(fmt::format("unknown channel {} in {}", internalId, msg.msg_type()));
    }

    auto& info = it->second;
    switch (dest) {
    case Peer::Downstream:
      if (!info.downstream_id.has_value()) {
        return absl::InvalidArgumentError(fmt::format("channel {} is not known to the downstream", internalId));
      }
      msg.recipient_channel = info.downstream_id.value();
      break;
    case Peer::Upstream:
      if (!info.upstream_id.has_value()) {
        return absl::InvalidArgumentError(fmt::format("channel {} is not known to the upstream", internalId));
      }
      msg.recipient_channel = info.upstream_id.value();
      break;
    }
    return absl::OkStatus();
  }

  void releaseInternalChannel(uint32_t id) {
    internal_channels_.erase(id);
    id_alloc_.release(id);
  }

  // auto newMiddleware(Source src, Dest dst) {
  //   return std::make_unique<Middleware>(*this, src, dst);
  // }

  struct internalChannelInfo {
    std::optional<uint32_t> upstream_id;
    std::optional<uint32_t> downstream_id;
  };

private:
  // class Middleware : public SshMessageMiddleware {
  // public:
  //   Middleware(ChannelIDManager& self, Source src, Dest dst)
  //       : self_(self),
  //         src_(src),
  //         dst_(dst) {}
  //   absl::StatusOr<MiddlewareResult> interceptMessage(wire::Message& msg) override {
  //     auto stat = msg.visit([&](wire::ChannelOpenMsg& msg) { return self_.processChannelOpenMsg(msg, src_); },
  //                           [&](wire::ChannelMsg auto& msg) { return self_.processChannelMsg(msg, dst_); },
  //                           [&](auto&) { return absl::OkStatus(); });
  //     if (!stat.ok()) {
  //       return stat;
  //     }
  //     return MiddlewareResult::Continue;
  //   }

  // private:
  //   ChannelIDManager& self_;
  //   const Source src_;
  //   const Dest dst_;
  // };

  absl::flat_hash_map<uint32_t, internalChannelInfo> internal_channels_;
  IDAllocator<uint32_t> id_alloc_;
};

} // namespace Envoy::Extensions::NetworkFilters::GenericProxy::Codec

DECL_BASIC_ENUM_FORMATTER(Envoy::Extensions::NetworkFilters::GenericProxy::Codec::Peer);
