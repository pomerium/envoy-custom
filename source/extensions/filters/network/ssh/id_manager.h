#pragma once

#include "fmt/args.h"
#include "source/common/id_alloc.h"
#include "source/extensions/filters/network/ssh/common.h"
#include "source/extensions/filters/network/ssh/wire/messages.h"
#include "source/extensions/filters/network/ssh/common.h"

#pragma clang unsafe_buffer_usage begin
#include "envoy/event/dispatcher.h"
#include "source/common/common/callback_impl.h"
#pragma clang unsafe_buffer_usage end

namespace Envoy::Extensions::NetworkFilters::GenericProxy::Codec {

constexpr uint32_t DefaultMaxConcurrentChannels = 32768;

enum Peer {
  Downstream = 0,
  Upstream = 1,
};

enum class ChannelIDState {
  // Default state. A channel is Unbound until a ChannelOpen request is received from the peer.
  Unbound = 0,
  // A channel is marked Pending when it is expected to become Bound because the opposite peer's
  // channel was bound. Pending is equivalent to Unbound except that it will prevent the channel
  // from being freed.
  Pending = 1,
  // A channel is Bound when the peer knows about this channel ID. A Bound channel may be in the
  // process of awaiting a ChannelOpenConfirmation or ChannelOpenFailure, depending on which side
  // initiated the channel open. If a peer is awaiting its opposite peer to bind the same internal
  // channel, the opposite peer is moved to the Pending state.
  Bound = 2,
  // A channel is Released when awaiting a close handshake between peers. A channel in this state is
  // still active until released by all bound peers.
  Released = 3,
  // A channel becomes Preempted when a ChannelClose is sent from one side of the transport to
  // its local peer. It exists in this state until a corresponding ChannelClose is received,
  // at which point it transitions to Bereft.
  // Transitioning from Bound to Preempted does not release the channel. A preempted channel must
  // still be released later for the ID to become freed.
  // Messages may only be sent to the peer for channels in this state until the next ChannelClose,
  // then any subsequent messages must be blocked.
  Preempted = 4,
  // A Bereft channel is one for which there is no longer a corresponding active channel known to
  // the peer. This state can be reached in two ways:
  // 1. A channel open request is initiated internally and rejected by the local peer.
  // 2. A channel is first preempted, then a ChannelClose is received by the local peer.
  // Messages must not be sent to the peer for channels in this state.
  Bereft = 5,
};

struct PeerLocalID {
  uint32_t channel_id;
  Peer local_peer;
};

struct InternalChannelInfo {
  std::array<uint32_t, 2> peer_ids;
  std::array<ChannelIDState, 2> peer_states;

  bool preempted_closed{};
  Peer owner{};
};

constexpr auto format_as(const InternalChannelInfo& info) {
  fmt::dynamic_format_arg_store<fmt::format_context> args;
  for (auto peer : {Peer::Upstream, Peer::Downstream}) {
    args.push_back(info.owner == peer ? "*" : "");
    args.push_back(info.peer_states[peer]);
    if (info.peer_states[peer] != ChannelIDState::Unbound) {
      args.push_back(":");
      args.push_back(info.peer_ids[peer]);
    } else {
      args.push_back("");
      args.push_back("");
    }
  }
  return fmt::vformat("U{}:{}{}{}|D{}:{}{}{}", args);
}

// Manages channel ID mappings.
// Channel IDs for proxied SSH connections are managed as follows:
//
// Both the downstream and upstream can open channels on the connection via ChannelOpenMsg. When
// doing so, whichever side opens the channel provides their own ID for that channel. Then, if the
// channel is opened successfully, the other side responds with *their* own channel ID for that
// channel. All channel messages after ChannelOpen, including the open response, have a field
// (in our messages, named 'recipient_channel') which contains the peer's channel ID for which the
// message applies. This ID is the one given by the peer itself.
//
// Thus, normally, any given channel can be identified by two separate IDs:
// 1. The ID provided by the downstream, which the upstream uses to send messages to the downstream
// 2. The ID provided by the upstream, which the downstream uses to send messages to the upstream
//
// In our case however, we maintain a third internal channel ID. Because we do not have control over
// the IDs generated by either party, forwarding channel IDs directly could lead to ID conflicts
// in some cases. For example, if we need to open a channel to the upstream ourselves, the
// downstream does not know this, and if it then tries to open another channel, it could generate
// the ID of a channel we have already created (the IDs are usually generated monotonically).
//
// To solve this, we do the following (note this is independent of which peer is the downstream or
// upstream, so we call them Alice and Bob):
// 1. A ChannelOpenMsg received from Alice has its 'sender_channel' field swapped with a
//    newly-generated internal channel ID before it is sent to Bob. The mapping between Alice's
//    sender_channel and ours is stored here, as the original sender_channel is the ID which must
//    be used when messages are ultimately sent back to Alice, regardless of source.
// 2. A ChannelOpenConfirmationMsg sent by Bob to Alice in response contains both sender_channel
//    and recipient_channel fields. The sender_channel here is Bob's new channel ID, and the
//    recipient_channel is *our* internal ID. Before forwarding this message to Alice, we will
//    make the following changes:
//    - The sender_channel (Bob's ID) is stored, and replaced with the recipient_channel (our ID).
//    - The recipient_channel is replaced with Alice's ID, obtained by lookup from our internal ID.
// 3. For any subsequent channel messages (see concept ChannelMsg), it can be assumed that the
//    recipient_channel refers to our internal ID. If the message is to be sent to Bob, the
//    recipient_channel is replaced with Bob's ID, which was tracked in (2). If the message is to
//    be sent to Alice, the recipient_channel is replaced with Alice's ID, which was tracked in (1).
//
// Internal channels keep track of the upstream and downstream channel IDs and whether or not they
// have been "bound" to the internal ID. The ID is only fully released for re-use once a matching
// call to releaseChannelID() has been made for each peer that has called bindChannelID() for the ID.
// Because individual Channel instances only handle messages read from their local peer, not
// messages sent from the remote peer, this allows a Channel to be destroyed when it is done
// handling any reads on the channel (i.e. after reading a ChannelClose message), and still allow
// the opposite peer to respond with their own ChannelClose message to the correct channel ID.
// At the protocol level, the channel is not "closed" until both sides have sent and received a
// ChannelClose message. Only when this happens is the ID released for re-use.
//
class ChannelIDManager : NonCopyable,
                         public StreamInfo::FilterState::Object,
                         public Logger::Loggable<Logger::Id::filter> {
public:
  ChannelIDManager(uint32_t start_id = 0, uint32_t id_limit = DefaultMaxConcurrentChannels)
      : id_alloc_(start_id, start_id + id_limit) {}

  absl::StatusOr<uint32_t> allocateNewChannel(Peer owner);

  absl::Status bindChannelID(uint32_t internal_id, PeerLocalID peer_local_id, bool expect_remote = true);
  void releaseChannelID(uint32_t internal_id, Peer local_peer);

  std::optional<Peer> owner(uint32_t internal_id);

  // Returns true if it is valid to call preempt() for a given channel ID and local peer, otherwise
  // false. A channel is eligible for preemption by a given peer if it is in the Bound state for
  // that peer, and it is in either the Bound or Unbound states for the opposite peer.
  bool isPreemptable(uint32_t internal_id, Peer local_peer);

  // Changes the peer state for a Bound channel to Preempted, which has the following effects:
  //
  // 1. Messages are allowed to be sent only until the next ChannelClose message, after which
  //    messages are blocked.
  //
  //    It is normally not necessary to check this condition and block messages explicitly; the
  //    protocol always disallows any channel messages to be sent after ChannelClose, so it's not
  //    something that should happen under normal conditions. However, in the case where the channel
  //    is preempted, the remote peer is not privy to the fact that we are breaking the rules (nor
  //    should it be). It may attempt to send its own ChannelClose for any reason, which is fine as
  //    long as it observes the same effects from doing so as it would normally.
  //
  // 2. When the channel is eventually released, its peer state transitions to Bereft, instead of
  //    Released.
  //
  //    This has implications for passthrough channels with two bound peers: if one peer preempts a
  //    channel, then receives a ChannelClose response, it will forward that message to the remote
  //    peer, which will respond with its own ChannelClose. This response from the remote peer must
  //    then be dropped, because the channel has already been fully closed on the local side (the
  //    remote peer is not aware of this). When the remote peer releases the ID, the channel is
  //    freed as usual. Bereft channels are considered the same as Released for purposes of
  //    determining whether to free an internal channel. Preempted channels are, however, not
  //    considered released and will hold the internal channel alive.
  void preempt(uint32_t internal_id, Peer local_peer);

  template <wire::ChannelMsg M>
  absl::StatusOr<bool> processOutgoingChannelMsg(M& msg, Peer dest) {
    return processOutgoingChannelMsgImpl(msg.recipient_channel, msg.msg_type(), dest);
  }

  size_t numActiveChannels() const { return internal_channels_.size(); }
  uint32_t nextInternalIdForTest() const { return id_alloc_.peekNext(); }

  [[nodiscard]]
  Envoy::Common::CallbackHandlePtr startDrain(Envoy::Event::Dispatcher& dispatcher, std::function<void()> complete_cb);

  std::optional<ChannelIDState> peerState(uint32_t internal_id, Peer peer);

private:
  absl::StatusOr<bool> processOutgoingChannelMsgImpl(wire::field<uint32_t>& recipient_channel,
                                                     wire::SshMessageType msg_type,
                                                     Peer dest);
#ifdef NDEBUG
  absl::flat_hash_map<uint32_t, InternalChannelInfo> internal_channels_;
#else
  std::unordered_map<uint32_t, InternalChannelInfo> internal_channels_;
#endif
  IDAllocator<uint32_t> id_alloc_;
  bool draining_{false};
  std::shared_ptr<Envoy::Common::ThreadSafeCallbackManager> drain_cb_ =
    Common::ThreadSafeCallbackManager::create();
};

} // namespace Envoy::Extensions::NetworkFilters::GenericProxy::Codec

DECL_BASIC_ENUM_FORMATTER(Envoy::Extensions::NetworkFilters::GenericProxy::Codec::Peer);
DECL_BASIC_ENUM_FORMATTER(Envoy::Extensions::NetworkFilters::GenericProxy::Codec::ChannelIDState);