// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/extensions/filters/network/ssh/ssh.proto

package ssh

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CodecConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CodecConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CodecConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CodecConfigMultiError, or
// nil if none found.
func (m *CodecConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CodecConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetHostKeys()) < 1 {
		err := CodecConfigValidationError{
			field:  "HostKeys",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetHostKeys() {
		_, _ = idx, item

		if item == nil {
			err := CodecConfigValidationError{
				field:  fmt.Sprintf("HostKeys[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CodecConfigValidationError{
						field:  fmt.Sprintf("HostKeys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CodecConfigValidationError{
						field:  fmt.Sprintf("HostKeys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CodecConfigValidationError{
					field:  fmt.Sprintf("HostKeys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetUserCaKey() == nil {
		err := CodecConfigValidationError{
			field:  "UserCaKey",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetUserCaKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CodecConfigValidationError{
					field:  "UserCaKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CodecConfigValidationError{
					field:  "UserCaKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserCaKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CodecConfigValidationError{
				field:  "UserCaKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if wrapper := m.GetRekeyThreshold(); wrapper != nil {

		if val := wrapper.GetValue(); val < 256 || val > 1073741824 {
			err := CodecConfigValidationError{
				field:  "RekeyThreshold",
				reason: "value must be inside range [256, 1073741824]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetGrpcService() == nil {
		err := CodecConfigValidationError{
			field:  "GrpcService",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetGrpcService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CodecConfigValidationError{
					field:  "GrpcService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CodecConfigValidationError{
					field:  "GrpcService",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrpcService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CodecConfigValidationError{
				field:  "GrpcService",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CodecConfigMultiError(errors)
	}

	return nil
}

// CodecConfigMultiError is an error wrapping multiple validation errors
// returned by CodecConfig.ValidateAll() if the designated constraints aren't met.
type CodecConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CodecConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CodecConfigMultiError) AllErrors() []error { return m }

// CodecConfigValidationError is the validation error returned by
// CodecConfig.Validate if the designated constraints aren't met.
type CodecConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CodecConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CodecConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CodecConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CodecConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CodecConfigValidationError) ErrorName() string { return "CodecConfigValidationError" }

// Error satisfies the builtin error interface
func (e CodecConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCodecConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CodecConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CodecConfigValidationError{}

// Validate checks the field values on ChannelMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChannelMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChannelMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChannelMessageMultiError,
// or nil if none found.
func (m *ChannelMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ChannelMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Message.(type) {
	case *ChannelMessage_Metadata:
		if v == nil {
			err := ChannelMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetadata()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChannelMessageValidationError{
						field:  "Metadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChannelMessageValidationError{
						field:  "Metadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChannelMessageValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ChannelMessage_RawBytes:
		if v == nil {
			err := ChannelMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRawBytes()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChannelMessageValidationError{
						field:  "RawBytes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChannelMessageValidationError{
						field:  "RawBytes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRawBytes()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChannelMessageValidationError{
					field:  "RawBytes",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ChannelMessage_ChannelControl:
		if v == nil {
			err := ChannelMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetChannelControl()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChannelMessageValidationError{
						field:  "ChannelControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChannelMessageValidationError{
						field:  "ChannelControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetChannelControl()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChannelMessageValidationError{
					field:  "ChannelControl",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ChannelMessageMultiError(errors)
	}

	return nil
}

// ChannelMessageMultiError is an error wrapping multiple validation errors
// returned by ChannelMessage.ValidateAll() if the designated constraints
// aren't met.
type ChannelMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChannelMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChannelMessageMultiError) AllErrors() []error { return m }

// ChannelMessageValidationError is the validation error returned by
// ChannelMessage.Validate if the designated constraints aren't met.
type ChannelMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChannelMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChannelMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChannelMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChannelMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChannelMessageValidationError) ErrorName() string { return "ChannelMessageValidationError" }

// Error satisfies the builtin error interface
func (e ChannelMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChannelMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChannelMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChannelMessageValidationError{}

// Validate checks the field values on ChannelControl with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChannelControl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChannelControl with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChannelControlMultiError,
// or nil if none found.
func (m *ChannelControl) ValidateAll() error {
	return m.validate(true)
}

func (m *ChannelControl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Protocol

	if all {
		switch v := interface{}(m.GetControlAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChannelControlValidationError{
					field:  "ControlAction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChannelControlValidationError{
					field:  "ControlAction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetControlAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChannelControlValidationError{
				field:  "ControlAction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChannelControlMultiError(errors)
	}

	return nil
}

// ChannelControlMultiError is an error wrapping multiple validation errors
// returned by ChannelControl.ValidateAll() if the designated constraints
// aren't met.
type ChannelControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChannelControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChannelControlMultiError) AllErrors() []error { return m }

// ChannelControlValidationError is the validation error returned by
// ChannelControl.Validate if the designated constraints aren't met.
type ChannelControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChannelControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChannelControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChannelControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChannelControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChannelControlValidationError) ErrorName() string { return "ChannelControlValidationError" }

// Error satisfies the builtin error interface
func (e ChannelControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChannelControl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChannelControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChannelControlValidationError{}

// Validate checks the field values on ClientMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClientMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClientMessageMultiError, or
// nil if none found.
func (m *ClientMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Message.(type) {
	case *ClientMessage_Event:
		if v == nil {
			err := ClientMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEvent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClientMessageValidationError{
						field:  "Event",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClientMessageValidationError{
						field:  "Event",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEvent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClientMessageValidationError{
					field:  "Event",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClientMessage_AuthRequest:
		if v == nil {
			err := ClientMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClientMessageValidationError{
						field:  "AuthRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClientMessageValidationError{
						field:  "AuthRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClientMessageValidationError{
					field:  "AuthRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ClientMessage_InfoResponse:
		if v == nil {
			err := ClientMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInfoResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClientMessageValidationError{
						field:  "InfoResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClientMessageValidationError{
						field:  "InfoResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInfoResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClientMessageValidationError{
					field:  "InfoResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ClientMessageMultiError(errors)
	}

	return nil
}

// ClientMessageMultiError is an error wrapping multiple validation errors
// returned by ClientMessage.ValidateAll() if the designated constraints
// aren't met.
type ClientMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientMessageMultiError) AllErrors() []error { return m }

// ClientMessageValidationError is the validation error returned by
// ClientMessage.Validate if the designated constraints aren't met.
type ClientMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientMessageValidationError) ErrorName() string { return "ClientMessageValidationError" }

// Error satisfies the builtin error interface
func (e ClientMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientMessageValidationError{}

// Validate checks the field values on StreamEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamEventMultiError, or
// nil if none found.
func (m *StreamEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Event.(type) {
	case *StreamEvent_DownstreamConnected:
		if v == nil {
			err := StreamEventValidationError{
				field:  "Event",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDownstreamConnected()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamEventValidationError{
						field:  "DownstreamConnected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamEventValidationError{
						field:  "DownstreamConnected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownstreamConnected()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamEventValidationError{
					field:  "DownstreamConnected",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *StreamEvent_DownstreamDisconnected:
		if v == nil {
			err := StreamEventValidationError{
				field:  "Event",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDownstreamDisconnected()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamEventValidationError{
						field:  "DownstreamDisconnected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamEventValidationError{
						field:  "DownstreamDisconnected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownstreamDisconnected()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamEventValidationError{
					field:  "DownstreamDisconnected",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *StreamEvent_UpstreamConnected:
		if v == nil {
			err := StreamEventValidationError{
				field:  "Event",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpstreamConnected()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamEventValidationError{
						field:  "UpstreamConnected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamEventValidationError{
						field:  "UpstreamConnected",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpstreamConnected()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamEventValidationError{
					field:  "UpstreamConnected",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StreamEventMultiError(errors)
	}

	return nil
}

// StreamEventMultiError is an error wrapping multiple validation errors
// returned by StreamEvent.ValidateAll() if the designated constraints aren't met.
type StreamEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamEventMultiError) AllErrors() []error { return m }

// StreamEventValidationError is the validation error returned by
// StreamEvent.Validate if the designated constraints aren't met.
type StreamEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamEventValidationError) ErrorName() string { return "StreamEventValidationError" }

// Error satisfies the builtin error interface
func (e StreamEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamEventValidationError{}

// Validate checks the field values on DownstreamConnectEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownstreamConnectEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownstreamConnectEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownstreamConnectEventMultiError, or nil if none found.
func (m *DownstreamConnectEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DownstreamConnectEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamId

	// no validation rules for SourceAddress

	if len(errors) > 0 {
		return DownstreamConnectEventMultiError(errors)
	}

	return nil
}

// DownstreamConnectEventMultiError is an error wrapping multiple validation
// errors returned by DownstreamConnectEvent.ValidateAll() if the designated
// constraints aren't met.
type DownstreamConnectEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownstreamConnectEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownstreamConnectEventMultiError) AllErrors() []error { return m }

// DownstreamConnectEventValidationError is the validation error returned by
// DownstreamConnectEvent.Validate if the designated constraints aren't met.
type DownstreamConnectEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownstreamConnectEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownstreamConnectEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownstreamConnectEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownstreamConnectEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownstreamConnectEventValidationError) ErrorName() string {
	return "DownstreamConnectEventValidationError"
}

// Error satisfies the builtin error interface
func (e DownstreamConnectEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownstreamConnectEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownstreamConnectEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownstreamConnectEventValidationError{}

// Validate checks the field values on DownstreamDisconnectedEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownstreamDisconnectedEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownstreamDisconnectedEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownstreamDisconnectedEventMultiError, or nil if none found.
func (m *DownstreamDisconnectedEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DownstreamDisconnectedEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	if len(errors) > 0 {
		return DownstreamDisconnectedEventMultiError(errors)
	}

	return nil
}

// DownstreamDisconnectedEventMultiError is an error wrapping multiple
// validation errors returned by DownstreamDisconnectedEvent.ValidateAll() if
// the designated constraints aren't met.
type DownstreamDisconnectedEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownstreamDisconnectedEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownstreamDisconnectedEventMultiError) AllErrors() []error { return m }

// DownstreamDisconnectedEventValidationError is the validation error returned
// by DownstreamDisconnectedEvent.Validate if the designated constraints
// aren't met.
type DownstreamDisconnectedEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownstreamDisconnectedEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownstreamDisconnectedEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownstreamDisconnectedEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownstreamDisconnectedEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownstreamDisconnectedEventValidationError) ErrorName() string {
	return "DownstreamDisconnectedEventValidationError"
}

// Error satisfies the builtin error interface
func (e DownstreamDisconnectedEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownstreamDisconnectedEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownstreamDisconnectedEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownstreamDisconnectedEventValidationError{}

// Validate checks the field values on UpstreamConnectEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpstreamConnectEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpstreamConnectEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpstreamConnectEventMultiError, or nil if none found.
func (m *UpstreamConnectEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *UpstreamConnectEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StreamId

	if len(errors) > 0 {
		return UpstreamConnectEventMultiError(errors)
	}

	return nil
}

// UpstreamConnectEventMultiError is an error wrapping multiple validation
// errors returned by UpstreamConnectEvent.ValidateAll() if the designated
// constraints aren't met.
type UpstreamConnectEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpstreamConnectEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpstreamConnectEventMultiError) AllErrors() []error { return m }

// UpstreamConnectEventValidationError is the validation error returned by
// UpstreamConnectEvent.Validate if the designated constraints aren't met.
type UpstreamConnectEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpstreamConnectEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpstreamConnectEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpstreamConnectEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpstreamConnectEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpstreamConnectEventValidationError) ErrorName() string {
	return "UpstreamConnectEventValidationError"
}

// Error satisfies the builtin error interface
func (e UpstreamConnectEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpstreamConnectEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpstreamConnectEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpstreamConnectEventValidationError{}

// Validate checks the field values on AuthenticationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenticationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthenticationRequestMultiError, or nil if none found.
func (m *AuthenticationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Protocol

	// no validation rules for Service

	// no validation rules for Username

	// no validation rules for Hostname

	// no validation rules for AuthMethod

	if all {
		switch v := interface{}(m.GetMethodRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthenticationRequestValidationError{
					field:  "MethodRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthenticationRequestValidationError{
					field:  "MethodRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMethodRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthenticationRequestValidationError{
				field:  "MethodRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthenticationRequestMultiError(errors)
	}

	return nil
}

// AuthenticationRequestMultiError is an error wrapping multiple validation
// errors returned by AuthenticationRequest.ValidateAll() if the designated
// constraints aren't met.
type AuthenticationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticationRequestMultiError) AllErrors() []error { return m }

// AuthenticationRequestValidationError is the validation error returned by
// AuthenticationRequest.Validate if the designated constraints aren't met.
type AuthenticationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticationRequestValidationError) ErrorName() string {
	return "AuthenticationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticationRequestValidationError{}

// Validate checks the field values on InfoResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InfoResponseMultiError, or
// nil if none found.
func (m *InfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Method

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InfoResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InfoResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InfoResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InfoResponseMultiError(errors)
	}

	return nil
}

// InfoResponseMultiError is an error wrapping multiple validation errors
// returned by InfoResponse.ValidateAll() if the designated constraints aren't met.
type InfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoResponseMultiError) AllErrors() []error { return m }

// InfoResponseValidationError is the validation error returned by
// InfoResponse.Validate if the designated constraints aren't met.
type InfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoResponseValidationError) ErrorName() string { return "InfoResponseValidationError" }

// Error satisfies the builtin error interface
func (e InfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoResponseValidationError{}

// Validate checks the field values on ServerMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServerMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServerMessageMultiError, or
// nil if none found.
func (m *ServerMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Message.(type) {
	case *ServerMessage_AuthResponse:
		if v == nil {
			err := ServerMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "AuthResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "AuthResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerMessageValidationError{
					field:  "AuthResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ServerMessage_StreamControl:
		if v == nil {
			err := ServerMessageValidationError{
				field:  "Message",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStreamControl()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "StreamControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerMessageValidationError{
						field:  "StreamControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStreamControl()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerMessageValidationError{
					field:  "StreamControl",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ServerMessageMultiError(errors)
	}

	return nil
}

// ServerMessageMultiError is an error wrapping multiple validation errors
// returned by ServerMessage.ValidateAll() if the designated constraints
// aren't met.
type ServerMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerMessageMultiError) AllErrors() []error { return m }

// ServerMessageValidationError is the validation error returned by
// ServerMessage.Validate if the designated constraints aren't met.
type ServerMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerMessageValidationError) ErrorName() string { return "ServerMessageValidationError" }

// Error satisfies the builtin error interface
func (e ServerMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerMessageValidationError{}

// Validate checks the field values on AuthenticationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenticationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenticationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthenticationResponseMultiError, or nil if none found.
func (m *AuthenticationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenticationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Response.(type) {
	case *AuthenticationResponse_Allow:
		if v == nil {
			err := AuthenticationResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAllow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticationResponseValidationError{
						field:  "Allow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticationResponseValidationError{
						field:  "Allow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAllow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticationResponseValidationError{
					field:  "Allow",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AuthenticationResponse_Deny:
		if v == nil {
			err := AuthenticationResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeny()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticationResponseValidationError{
						field:  "Deny",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticationResponseValidationError{
						field:  "Deny",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeny()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticationResponseValidationError{
					field:  "Deny",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AuthenticationResponse_InfoRequest:
		if v == nil {
			err := AuthenticationResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInfoRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthenticationResponseValidationError{
						field:  "InfoRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthenticationResponseValidationError{
						field:  "InfoRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInfoRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthenticationResponseValidationError{
					field:  "InfoRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuthenticationResponseMultiError(errors)
	}

	return nil
}

// AuthenticationResponseMultiError is an error wrapping multiple validation
// errors returned by AuthenticationResponse.ValidateAll() if the designated
// constraints aren't met.
type AuthenticationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticationResponseMultiError) AllErrors() []error { return m }

// AuthenticationResponseValidationError is the validation error returned by
// AuthenticationResponse.Validate if the designated constraints aren't met.
type AuthenticationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticationResponseValidationError) ErrorName() string {
	return "AuthenticationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenticationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenticationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticationResponseValidationError{}

// Validate checks the field values on AllowResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AllowResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllowResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AllowResponseMultiError, or
// nil if none found.
func (m *AllowResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AllowResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	switch v := m.Target.(type) {
	case *AllowResponse_Upstream:
		if v == nil {
			err := AllowResponseValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUpstream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AllowResponseValidationError{
						field:  "Upstream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AllowResponseValidationError{
						field:  "Upstream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpstream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AllowResponseValidationError{
					field:  "Upstream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AllowResponse_Internal:
		if v == nil {
			err := AllowResponseValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInternal()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AllowResponseValidationError{
						field:  "Internal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AllowResponseValidationError{
						field:  "Internal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInternal()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AllowResponseValidationError{
					field:  "Internal",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AllowResponse_MirrorSession:
		if v == nil {
			err := AllowResponseValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMirrorSession()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AllowResponseValidationError{
						field:  "MirrorSession",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AllowResponseValidationError{
						field:  "MirrorSession",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMirrorSession()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AllowResponseValidationError{
					field:  "MirrorSession",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AllowResponseMultiError(errors)
	}

	return nil
}

// AllowResponseMultiError is an error wrapping multiple validation errors
// returned by AllowResponse.ValidateAll() if the designated constraints
// aren't met.
type AllowResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllowResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllowResponseMultiError) AllErrors() []error { return m }

// AllowResponseValidationError is the validation error returned by
// AllowResponse.Validate if the designated constraints aren't met.
type AllowResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllowResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllowResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllowResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllowResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllowResponseValidationError) ErrorName() string { return "AllowResponseValidationError" }

// Error satisfies the builtin error interface
func (e AllowResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllowResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllowResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllowResponseValidationError{}

// Validate checks the field values on UpstreamTarget with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpstreamTarget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpstreamTarget with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpstreamTargetMultiError,
// or nil if none found.
func (m *UpstreamTarget) ValidateAll() error {
	return m.validate(true)
}

func (m *UpstreamTarget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hostname

	// no validation rules for AllowMirrorConnections

	// no validation rules for DirectTcpip

	for idx, item := range m.GetAllowedMethods() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpstreamTargetValidationError{
						field:  fmt.Sprintf("AllowedMethods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpstreamTargetValidationError{
						field:  fmt.Sprintf("AllowedMethods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpstreamTargetValidationError{
					field:  fmt.Sprintf("AllowedMethods[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExtensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpstreamTargetValidationError{
						field:  fmt.Sprintf("Extensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpstreamTargetValidationError{
						field:  fmt.Sprintf("Extensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpstreamTargetValidationError{
					field:  fmt.Sprintf("Extensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpstreamTargetMultiError(errors)
	}

	return nil
}

// UpstreamTargetMultiError is an error wrapping multiple validation errors
// returned by UpstreamTarget.ValidateAll() if the designated constraints
// aren't met.
type UpstreamTargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpstreamTargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpstreamTargetMultiError) AllErrors() []error { return m }

// UpstreamTargetValidationError is the validation error returned by
// UpstreamTarget.Validate if the designated constraints aren't met.
type UpstreamTargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpstreamTargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpstreamTargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpstreamTargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpstreamTargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpstreamTargetValidationError) ErrorName() string { return "UpstreamTargetValidationError" }

// Error satisfies the builtin error interface
func (e UpstreamTargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpstreamTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpstreamTargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpstreamTargetValidationError{}

// Validate checks the field values on InternalTarget with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InternalTarget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InternalTarget with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InternalTargetMultiError,
// or nil if none found.
func (m *InternalTarget) ValidateAll() error {
	return m.validate(true)
}

func (m *InternalTarget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InternalTargetValidationError{
					field:  "SetMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InternalTargetValidationError{
					field:  "SetMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InternalTargetValidationError{
				field:  "SetMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InternalTargetMultiError(errors)
	}

	return nil
}

// InternalTargetMultiError is an error wrapping multiple validation errors
// returned by InternalTarget.ValidateAll() if the designated constraints
// aren't met.
type InternalTargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InternalTargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InternalTargetMultiError) AllErrors() []error { return m }

// InternalTargetValidationError is the validation error returned by
// InternalTarget.Validate if the designated constraints aren't met.
type InternalTargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InternalTargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InternalTargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InternalTargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InternalTargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InternalTargetValidationError) ErrorName() string { return "InternalTargetValidationError" }

// Error satisfies the builtin error interface
func (e InternalTargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInternalTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InternalTargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InternalTargetValidationError{}

// Validate checks the field values on MirrorSessionTarget with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MirrorSessionTarget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MirrorSessionTarget with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MirrorSessionTargetMultiError, or nil if none found.
func (m *MirrorSessionTarget) ValidateAll() error {
	return m.validate(true)
}

func (m *MirrorSessionTarget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceId

	// no validation rules for Mode

	if len(errors) > 0 {
		return MirrorSessionTargetMultiError(errors)
	}

	return nil
}

// MirrorSessionTargetMultiError is an error wrapping multiple validation
// errors returned by MirrorSessionTarget.ValidateAll() if the designated
// constraints aren't met.
type MirrorSessionTargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MirrorSessionTargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MirrorSessionTargetMultiError) AllErrors() []error { return m }

// MirrorSessionTargetValidationError is the validation error returned by
// MirrorSessionTarget.Validate if the designated constraints aren't met.
type MirrorSessionTargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MirrorSessionTargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MirrorSessionTargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MirrorSessionTargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MirrorSessionTargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MirrorSessionTargetValidationError) ErrorName() string {
	return "MirrorSessionTargetValidationError"
}

// Error satisfies the builtin error interface
func (e MirrorSessionTargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMirrorSessionTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MirrorSessionTargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MirrorSessionTargetValidationError{}

// Validate checks the field values on AllowedMethod with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AllowedMethod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllowedMethod with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AllowedMethodMultiError, or
// nil if none found.
func (m *AllowedMethod) ValidateAll() error {
	return m.validate(true)
}

func (m *AllowedMethod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Method

	if all {
		switch v := interface{}(m.GetMethodData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AllowedMethodValidationError{
					field:  "MethodData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AllowedMethodValidationError{
					field:  "MethodData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMethodData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AllowedMethodValidationError{
				field:  "MethodData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AllowedMethodMultiError(errors)
	}

	return nil
}

// AllowedMethodMultiError is an error wrapping multiple validation errors
// returned by AllowedMethod.ValidateAll() if the designated constraints
// aren't met.
type AllowedMethodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllowedMethodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllowedMethodMultiError) AllErrors() []error { return m }

// AllowedMethodValidationError is the validation error returned by
// AllowedMethod.Validate if the designated constraints aren't met.
type AllowedMethodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllowedMethodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllowedMethodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllowedMethodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllowedMethodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllowedMethodValidationError) ErrorName() string { return "AllowedMethodValidationError" }

// Error satisfies the builtin error interface
func (e AllowedMethodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllowedMethod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllowedMethodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllowedMethodValidationError{}

// Validate checks the field values on DenyResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DenyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DenyResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DenyResponseMultiError, or
// nil if none found.
func (m *DenyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DenyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partial

	if len(errors) > 0 {
		return DenyResponseMultiError(errors)
	}

	return nil
}

// DenyResponseMultiError is an error wrapping multiple validation errors
// returned by DenyResponse.ValidateAll() if the designated constraints aren't met.
type DenyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DenyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DenyResponseMultiError) AllErrors() []error { return m }

// DenyResponseValidationError is the validation error returned by
// DenyResponse.Validate if the designated constraints aren't met.
type DenyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DenyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DenyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DenyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DenyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DenyResponseValidationError) ErrorName() string { return "DenyResponseValidationError" }

// Error satisfies the builtin error interface
func (e DenyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDenyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DenyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DenyResponseValidationError{}

// Validate checks the field values on InfoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InfoRequestMultiError, or
// nil if none found.
func (m *InfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Method

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InfoRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InfoRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InfoRequestValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InfoRequestMultiError(errors)
	}

	return nil
}

// InfoRequestMultiError is an error wrapping multiple validation errors
// returned by InfoRequest.ValidateAll() if the designated constraints aren't met.
type InfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoRequestMultiError) AllErrors() []error { return m }

// InfoRequestValidationError is the validation error returned by
// InfoRequest.Validate if the designated constraints aren't met.
type InfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoRequestValidationError) ErrorName() string { return "InfoRequestValidationError" }

// Error satisfies the builtin error interface
func (e InfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoRequestValidationError{}

// Validate checks the field values on StreamControl with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamControl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamControl with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamControlMultiError, or
// nil if none found.
func (m *StreamControl) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamControl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Action.(type) {
	case *StreamControl_CloseStream_:
		if v == nil {
			err := StreamControlValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCloseStream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StreamControlValidationError{
						field:  "CloseStream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StreamControlValidationError{
						field:  "CloseStream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCloseStream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StreamControlValidationError{
					field:  "CloseStream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StreamControlMultiError(errors)
	}

	return nil
}

// StreamControlMultiError is an error wrapping multiple validation errors
// returned by StreamControl.ValidateAll() if the designated constraints
// aren't met.
type StreamControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamControlMultiError) AllErrors() []error { return m }

// StreamControlValidationError is the validation error returned by
// StreamControl.Validate if the designated constraints aren't met.
type StreamControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamControlValidationError) ErrorName() string { return "StreamControlValidationError" }

// Error satisfies the builtin error interface
func (e StreamControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamControl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamControlValidationError{}

// Validate checks the field values on SSHDownstreamChannelInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SSHDownstreamChannelInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHDownstreamChannelInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SSHDownstreamChannelInfoMultiError, or nil if none found.
func (m *SSHDownstreamChannelInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHDownstreamChannelInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelType

	// no validation rules for DownstreamChannelId

	// no validation rules for InternalUpstreamChannelId

	// no validation rules for InitialWindowSize

	// no validation rules for MaxPacketSize

	if len(errors) > 0 {
		return SSHDownstreamChannelInfoMultiError(errors)
	}

	return nil
}

// SSHDownstreamChannelInfoMultiError is an error wrapping multiple validation
// errors returned by SSHDownstreamChannelInfo.ValidateAll() if the designated
// constraints aren't met.
type SSHDownstreamChannelInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHDownstreamChannelInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHDownstreamChannelInfoMultiError) AllErrors() []error { return m }

// SSHDownstreamChannelInfoValidationError is the validation error returned by
// SSHDownstreamChannelInfo.Validate if the designated constraints aren't met.
type SSHDownstreamChannelInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHDownstreamChannelInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHDownstreamChannelInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHDownstreamChannelInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHDownstreamChannelInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHDownstreamChannelInfoValidationError) ErrorName() string {
	return "SSHDownstreamChannelInfoValidationError"
}

// Error satisfies the builtin error interface
func (e SSHDownstreamChannelInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHDownstreamChannelInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHDownstreamChannelInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHDownstreamChannelInfoValidationError{}

// Validate checks the field values on SSHDownstreamPTYInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SSHDownstreamPTYInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHDownstreamPTYInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SSHDownstreamPTYInfoMultiError, or nil if none found.
func (m *SSHDownstreamPTYInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHDownstreamPTYInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TermEnv

	// no validation rules for WidthColumns

	// no validation rules for HeightRows

	// no validation rules for WidthPx

	// no validation rules for HeightPx

	// no validation rules for Modes

	if len(errors) > 0 {
		return SSHDownstreamPTYInfoMultiError(errors)
	}

	return nil
}

// SSHDownstreamPTYInfoMultiError is an error wrapping multiple validation
// errors returned by SSHDownstreamPTYInfo.ValidateAll() if the designated
// constraints aren't met.
type SSHDownstreamPTYInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHDownstreamPTYInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHDownstreamPTYInfoMultiError) AllErrors() []error { return m }

// SSHDownstreamPTYInfoValidationError is the validation error returned by
// SSHDownstreamPTYInfo.Validate if the designated constraints aren't met.
type SSHDownstreamPTYInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHDownstreamPTYInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHDownstreamPTYInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHDownstreamPTYInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHDownstreamPTYInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHDownstreamPTYInfoValidationError) ErrorName() string {
	return "SSHDownstreamPTYInfoValidationError"
}

// Error satisfies the builtin error interface
func (e SSHDownstreamPTYInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHDownstreamPTYInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHDownstreamPTYInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHDownstreamPTYInfoValidationError{}

// Validate checks the field values on SSHChannelControlAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SSHChannelControlAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHChannelControlAction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SSHChannelControlActionMultiError, or nil if none found.
func (m *SSHChannelControlAction) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHChannelControlAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Action.(type) {
	case *SSHChannelControlAction_Disconnect_:
		if v == nil {
			err := SSHChannelControlActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDisconnect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SSHChannelControlActionValidationError{
						field:  "Disconnect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SSHChannelControlActionValidationError{
						field:  "Disconnect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDisconnect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SSHChannelControlActionValidationError{
					field:  "Disconnect",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SSHChannelControlAction_HandOff:
		if v == nil {
			err := SSHChannelControlActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHandOff()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SSHChannelControlActionValidationError{
						field:  "HandOff",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SSHChannelControlActionValidationError{
						field:  "HandOff",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHandOff()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SSHChannelControlActionValidationError{
					field:  "HandOff",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SSHChannelControlActionMultiError(errors)
	}

	return nil
}

// SSHChannelControlActionMultiError is an error wrapping multiple validation
// errors returned by SSHChannelControlAction.ValidateAll() if the designated
// constraints aren't met.
type SSHChannelControlActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHChannelControlActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHChannelControlActionMultiError) AllErrors() []error { return m }

// SSHChannelControlActionValidationError is the validation error returned by
// SSHChannelControlAction.Validate if the designated constraints aren't met.
type SSHChannelControlActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHChannelControlActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHChannelControlActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHChannelControlActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHChannelControlActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHChannelControlActionValidationError) ErrorName() string {
	return "SSHChannelControlActionValidationError"
}

// Error satisfies the builtin error interface
func (e SSHChannelControlActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHChannelControlAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHChannelControlActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHChannelControlActionValidationError{}

// Validate checks the field values on PublicKeyMethodRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PublicKeyMethodRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PublicKeyMethodRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PublicKeyMethodRequestMultiError, or nil if none found.
func (m *PublicKeyMethodRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PublicKeyMethodRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PublicKey

	// no validation rules for PublicKeyAlg

	if len(errors) > 0 {
		return PublicKeyMethodRequestMultiError(errors)
	}

	return nil
}

// PublicKeyMethodRequestMultiError is an error wrapping multiple validation
// errors returned by PublicKeyMethodRequest.ValidateAll() if the designated
// constraints aren't met.
type PublicKeyMethodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PublicKeyMethodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PublicKeyMethodRequestMultiError) AllErrors() []error { return m }

// PublicKeyMethodRequestValidationError is the validation error returned by
// PublicKeyMethodRequest.Validate if the designated constraints aren't met.
type PublicKeyMethodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PublicKeyMethodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PublicKeyMethodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PublicKeyMethodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PublicKeyMethodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PublicKeyMethodRequestValidationError) ErrorName() string {
	return "PublicKeyMethodRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PublicKeyMethodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPublicKeyMethodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PublicKeyMethodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PublicKeyMethodRequestValidationError{}

// Validate checks the field values on PublicKeyAllowResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PublicKeyAllowResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PublicKeyAllowResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PublicKeyAllowResponseMultiError, or nil if none found.
func (m *PublicKeyAllowResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PublicKeyAllowResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PublicKey

	if all {
		switch v := interface{}(m.GetPermissions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PublicKeyAllowResponseValidationError{
					field:  "Permissions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PublicKeyAllowResponseValidationError{
					field:  "Permissions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPermissions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PublicKeyAllowResponseValidationError{
				field:  "Permissions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PublicKeyAllowResponseMultiError(errors)
	}

	return nil
}

// PublicKeyAllowResponseMultiError is an error wrapping multiple validation
// errors returned by PublicKeyAllowResponse.ValidateAll() if the designated
// constraints aren't met.
type PublicKeyAllowResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PublicKeyAllowResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PublicKeyAllowResponseMultiError) AllErrors() []error { return m }

// PublicKeyAllowResponseValidationError is the validation error returned by
// PublicKeyAllowResponse.Validate if the designated constraints aren't met.
type PublicKeyAllowResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PublicKeyAllowResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PublicKeyAllowResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PublicKeyAllowResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PublicKeyAllowResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PublicKeyAllowResponseValidationError) ErrorName() string {
	return "PublicKeyAllowResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PublicKeyAllowResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPublicKeyAllowResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PublicKeyAllowResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PublicKeyAllowResponseValidationError{}

// Validate checks the field values on KeyboardInteractiveMethodRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *KeyboardInteractiveMethodRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyboardInteractiveMethodRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// KeyboardInteractiveMethodRequestMultiError, or nil if none found.
func (m *KeyboardInteractiveMethodRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyboardInteractiveMethodRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return KeyboardInteractiveMethodRequestMultiError(errors)
	}

	return nil
}

// KeyboardInteractiveMethodRequestMultiError is an error wrapping multiple
// validation errors returned by
// KeyboardInteractiveMethodRequest.ValidateAll() if the designated
// constraints aren't met.
type KeyboardInteractiveMethodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyboardInteractiveMethodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyboardInteractiveMethodRequestMultiError) AllErrors() []error { return m }

// KeyboardInteractiveMethodRequestValidationError is the validation error
// returned by KeyboardInteractiveMethodRequest.Validate if the designated
// constraints aren't met.
type KeyboardInteractiveMethodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyboardInteractiveMethodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyboardInteractiveMethodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyboardInteractiveMethodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyboardInteractiveMethodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyboardInteractiveMethodRequestValidationError) ErrorName() string {
	return "KeyboardInteractiveMethodRequestValidationError"
}

// Error satisfies the builtin error interface
func (e KeyboardInteractiveMethodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyboardInteractiveMethodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyboardInteractiveMethodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyboardInteractiveMethodRequestValidationError{}

// Validate checks the field values on KeyboardInteractiveAllowResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *KeyboardInteractiveAllowResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyboardInteractiveAllowResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// KeyboardInteractiveAllowResponseMultiError, or nil if none found.
func (m *KeyboardInteractiveAllowResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyboardInteractiveAllowResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for UserId

	{
		sorted_keys := make([]string, len(m.GetClaims()))
		i := 0
		for key := range m.GetClaims() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClaims()[key]
			_ = val

			// no validation rules for Claims[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, KeyboardInteractiveAllowResponseValidationError{
							field:  fmt.Sprintf("Claims[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, KeyboardInteractiveAllowResponseValidationError{
							field:  fmt.Sprintf("Claims[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return KeyboardInteractiveAllowResponseValidationError{
						field:  fmt.Sprintf("Claims[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return KeyboardInteractiveAllowResponseMultiError(errors)
	}

	return nil
}

// KeyboardInteractiveAllowResponseMultiError is an error wrapping multiple
// validation errors returned by
// KeyboardInteractiveAllowResponse.ValidateAll() if the designated
// constraints aren't met.
type KeyboardInteractiveAllowResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyboardInteractiveAllowResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyboardInteractiveAllowResponseMultiError) AllErrors() []error { return m }

// KeyboardInteractiveAllowResponseValidationError is the validation error
// returned by KeyboardInteractiveAllowResponse.Validate if the designated
// constraints aren't met.
type KeyboardInteractiveAllowResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyboardInteractiveAllowResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyboardInteractiveAllowResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyboardInteractiveAllowResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyboardInteractiveAllowResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyboardInteractiveAllowResponseValidationError) ErrorName() string {
	return "KeyboardInteractiveAllowResponseValidationError"
}

// Error satisfies the builtin error interface
func (e KeyboardInteractiveAllowResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyboardInteractiveAllowResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyboardInteractiveAllowResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyboardInteractiveAllowResponseValidationError{}

// Validate checks the field values on KeyboardInteractiveInfoPrompts with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KeyboardInteractiveInfoPrompts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyboardInteractiveInfoPrompts with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// KeyboardInteractiveInfoPromptsMultiError, or nil if none found.
func (m *KeyboardInteractiveInfoPrompts) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyboardInteractiveInfoPrompts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Instruction

	// no validation rules for LanguageTag

	for idx, item := range m.GetPrompts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KeyboardInteractiveInfoPromptsValidationError{
						field:  fmt.Sprintf("Prompts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KeyboardInteractiveInfoPromptsValidationError{
						field:  fmt.Sprintf("Prompts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KeyboardInteractiveInfoPromptsValidationError{
					field:  fmt.Sprintf("Prompts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return KeyboardInteractiveInfoPromptsMultiError(errors)
	}

	return nil
}

// KeyboardInteractiveInfoPromptsMultiError is an error wrapping multiple
// validation errors returned by KeyboardInteractiveInfoPrompts.ValidateAll()
// if the designated constraints aren't met.
type KeyboardInteractiveInfoPromptsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyboardInteractiveInfoPromptsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyboardInteractiveInfoPromptsMultiError) AllErrors() []error { return m }

// KeyboardInteractiveInfoPromptsValidationError is the validation error
// returned by KeyboardInteractiveInfoPrompts.Validate if the designated
// constraints aren't met.
type KeyboardInteractiveInfoPromptsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyboardInteractiveInfoPromptsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyboardInteractiveInfoPromptsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyboardInteractiveInfoPromptsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyboardInteractiveInfoPromptsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyboardInteractiveInfoPromptsValidationError) ErrorName() string {
	return "KeyboardInteractiveInfoPromptsValidationError"
}

// Error satisfies the builtin error interface
func (e KeyboardInteractiveInfoPromptsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyboardInteractiveInfoPrompts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyboardInteractiveInfoPromptsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyboardInteractiveInfoPromptsValidationError{}

// Validate checks the field values on KeyboardInteractiveInfoPromptResponses
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *KeyboardInteractiveInfoPromptResponses) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// KeyboardInteractiveInfoPromptResponses with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// KeyboardInteractiveInfoPromptResponsesMultiError, or nil if none found.
func (m *KeyboardInteractiveInfoPromptResponses) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyboardInteractiveInfoPromptResponses) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return KeyboardInteractiveInfoPromptResponsesMultiError(errors)
	}

	return nil
}

// KeyboardInteractiveInfoPromptResponsesMultiError is an error wrapping
// multiple validation errors returned by
// KeyboardInteractiveInfoPromptResponses.ValidateAll() if the designated
// constraints aren't met.
type KeyboardInteractiveInfoPromptResponsesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyboardInteractiveInfoPromptResponsesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyboardInteractiveInfoPromptResponsesMultiError) AllErrors() []error { return m }

// KeyboardInteractiveInfoPromptResponsesValidationError is the validation
// error returned by KeyboardInteractiveInfoPromptResponses.Validate if the
// designated constraints aren't met.
type KeyboardInteractiveInfoPromptResponsesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyboardInteractiveInfoPromptResponsesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyboardInteractiveInfoPromptResponsesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyboardInteractiveInfoPromptResponsesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyboardInteractiveInfoPromptResponsesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyboardInteractiveInfoPromptResponsesValidationError) ErrorName() string {
	return "KeyboardInteractiveInfoPromptResponsesValidationError"
}

// Error satisfies the builtin error interface
func (e KeyboardInteractiveInfoPromptResponsesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyboardInteractiveInfoPromptResponses.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyboardInteractiveInfoPromptResponsesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyboardInteractiveInfoPromptResponsesValidationError{}

// Validate checks the field values on Permissions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Permissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Permissions with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PermissionsMultiError, or
// nil if none found.
func (m *Permissions) ValidateAll() error {
	return m.validate(true)
}

func (m *Permissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PermitPortForwarding

	// no validation rules for PermitAgentForwarding

	// no validation rules for PermitX11Forwarding

	// no validation rules for PermitPty

	// no validation rules for PermitUserRc

	if all {
		switch v := interface{}(m.GetValidBefore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PermissionsValidationError{
					field:  "ValidBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PermissionsValidationError{
					field:  "ValidBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidBefore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PermissionsValidationError{
				field:  "ValidBefore",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetValidAfter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PermissionsValidationError{
					field:  "ValidAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PermissionsValidationError{
					field:  "ValidAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidAfter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PermissionsValidationError{
				field:  "ValidAfter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ForceCommand

	// no validation rules for ForceEnv

	// no validation rules for RequireUserPresence

	// no validation rules for RequireVerify

	if len(errors) > 0 {
		return PermissionsMultiError(errors)
	}

	return nil
}

// PermissionsMultiError is an error wrapping multiple validation errors
// returned by Permissions.ValidateAll() if the designated constraints aren't met.
type PermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionsMultiError) AllErrors() []error { return m }

// PermissionsValidationError is the validation error returned by
// Permissions.Validate if the designated constraints aren't met.
type PermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionsValidationError) ErrorName() string { return "PermissionsValidationError" }

// Error satisfies the builtin error interface
func (e PermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionsValidationError{}

// Validate checks the field values on StreamControl_CloseStream with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StreamControl_CloseStream) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamControl_CloseStream with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StreamControl_CloseStreamMultiError, or nil if none found.
func (m *StreamControl_CloseStream) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamControl_CloseStream) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	if len(errors) > 0 {
		return StreamControl_CloseStreamMultiError(errors)
	}

	return nil
}

// StreamControl_CloseStreamMultiError is an error wrapping multiple validation
// errors returned by StreamControl_CloseStream.ValidateAll() if the
// designated constraints aren't met.
type StreamControl_CloseStreamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamControl_CloseStreamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamControl_CloseStreamMultiError) AllErrors() []error { return m }

// StreamControl_CloseStreamValidationError is the validation error returned by
// StreamControl_CloseStream.Validate if the designated constraints aren't met.
type StreamControl_CloseStreamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamControl_CloseStreamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamControl_CloseStreamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamControl_CloseStreamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamControl_CloseStreamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamControl_CloseStreamValidationError) ErrorName() string {
	return "StreamControl_CloseStreamValidationError"
}

// Error satisfies the builtin error interface
func (e StreamControl_CloseStreamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamControl_CloseStream.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamControl_CloseStreamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamControl_CloseStreamValidationError{}

// Validate checks the field values on SSHChannelControlAction_Disconnect with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SSHChannelControlAction_Disconnect) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHChannelControlAction_Disconnect
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SSHChannelControlAction_DisconnectMultiError, or nil if none found.
func (m *SSHChannelControlAction_Disconnect) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHChannelControlAction_Disconnect) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReasonCode

	// no validation rules for Description

	if len(errors) > 0 {
		return SSHChannelControlAction_DisconnectMultiError(errors)
	}

	return nil
}

// SSHChannelControlAction_DisconnectMultiError is an error wrapping multiple
// validation errors returned by
// SSHChannelControlAction_Disconnect.ValidateAll() if the designated
// constraints aren't met.
type SSHChannelControlAction_DisconnectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHChannelControlAction_DisconnectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHChannelControlAction_DisconnectMultiError) AllErrors() []error { return m }

// SSHChannelControlAction_DisconnectValidationError is the validation error
// returned by SSHChannelControlAction_Disconnect.Validate if the designated
// constraints aren't met.
type SSHChannelControlAction_DisconnectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHChannelControlAction_DisconnectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHChannelControlAction_DisconnectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHChannelControlAction_DisconnectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHChannelControlAction_DisconnectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHChannelControlAction_DisconnectValidationError) ErrorName() string {
	return "SSHChannelControlAction_DisconnectValidationError"
}

// Error satisfies the builtin error interface
func (e SSHChannelControlAction_DisconnectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHChannelControlAction_Disconnect.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHChannelControlAction_DisconnectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHChannelControlAction_DisconnectValidationError{}

// Validate checks the field values on SSHChannelControlAction_HandOffUpstream
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *SSHChannelControlAction_HandOffUpstream) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// SSHChannelControlAction_HandOffUpstream with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// SSHChannelControlAction_HandOffUpstreamMultiError, or nil if none found.
func (m *SSHChannelControlAction_HandOffUpstream) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHChannelControlAction_HandOffUpstream) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDownstreamChannelInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SSHChannelControlAction_HandOffUpstreamValidationError{
					field:  "DownstreamChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SSHChannelControlAction_HandOffUpstreamValidationError{
					field:  "DownstreamChannelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDownstreamChannelInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SSHChannelControlAction_HandOffUpstreamValidationError{
				field:  "DownstreamChannelInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDownstreamPtyInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SSHChannelControlAction_HandOffUpstreamValidationError{
					field:  "DownstreamPtyInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SSHChannelControlAction_HandOffUpstreamValidationError{
					field:  "DownstreamPtyInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDownstreamPtyInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SSHChannelControlAction_HandOffUpstreamValidationError{
				field:  "DownstreamPtyInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpstreamAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SSHChannelControlAction_HandOffUpstreamValidationError{
					field:  "UpstreamAuth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SSHChannelControlAction_HandOffUpstreamValidationError{
					field:  "UpstreamAuth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpstreamAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SSHChannelControlAction_HandOffUpstreamValidationError{
				field:  "UpstreamAuth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SSHChannelControlAction_HandOffUpstreamMultiError(errors)
	}

	return nil
}

// SSHChannelControlAction_HandOffUpstreamMultiError is an error wrapping
// multiple validation errors returned by
// SSHChannelControlAction_HandOffUpstream.ValidateAll() if the designated
// constraints aren't met.
type SSHChannelControlAction_HandOffUpstreamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHChannelControlAction_HandOffUpstreamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHChannelControlAction_HandOffUpstreamMultiError) AllErrors() []error { return m }

// SSHChannelControlAction_HandOffUpstreamValidationError is the validation
// error returned by SSHChannelControlAction_HandOffUpstream.Validate if the
// designated constraints aren't met.
type SSHChannelControlAction_HandOffUpstreamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHChannelControlAction_HandOffUpstreamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHChannelControlAction_HandOffUpstreamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHChannelControlAction_HandOffUpstreamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHChannelControlAction_HandOffUpstreamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHChannelControlAction_HandOffUpstreamValidationError) ErrorName() string {
	return "SSHChannelControlAction_HandOffUpstreamValidationError"
}

// Error satisfies the builtin error interface
func (e SSHChannelControlAction_HandOffUpstreamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHChannelControlAction_HandOffUpstream.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHChannelControlAction_HandOffUpstreamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHChannelControlAction_HandOffUpstreamValidationError{}

// Validate checks the field values on KeyboardInteractiveInfoPrompts_Prompt
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *KeyboardInteractiveInfoPrompts_Prompt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyboardInteractiveInfoPrompts_Prompt
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// KeyboardInteractiveInfoPrompts_PromptMultiError, or nil if none found.
func (m *KeyboardInteractiveInfoPrompts_Prompt) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyboardInteractiveInfoPrompts_Prompt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Prompt

	// no validation rules for Echo

	if len(errors) > 0 {
		return KeyboardInteractiveInfoPrompts_PromptMultiError(errors)
	}

	return nil
}

// KeyboardInteractiveInfoPrompts_PromptMultiError is an error wrapping
// multiple validation errors returned by
// KeyboardInteractiveInfoPrompts_Prompt.ValidateAll() if the designated
// constraints aren't met.
type KeyboardInteractiveInfoPrompts_PromptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyboardInteractiveInfoPrompts_PromptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyboardInteractiveInfoPrompts_PromptMultiError) AllErrors() []error { return m }

// KeyboardInteractiveInfoPrompts_PromptValidationError is the validation error
// returned by KeyboardInteractiveInfoPrompts_Prompt.Validate if the
// designated constraints aren't met.
type KeyboardInteractiveInfoPrompts_PromptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyboardInteractiveInfoPrompts_PromptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyboardInteractiveInfoPrompts_PromptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyboardInteractiveInfoPrompts_PromptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyboardInteractiveInfoPrompts_PromptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyboardInteractiveInfoPrompts_PromptValidationError) ErrorName() string {
	return "KeyboardInteractiveInfoPrompts_PromptValidationError"
}

// Error satisfies the builtin error interface
func (e KeyboardInteractiveInfoPrompts_PromptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyboardInteractiveInfoPrompts_Prompt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyboardInteractiveInfoPrompts_PromptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyboardInteractiveInfoPrompts_PromptValidationError{}
